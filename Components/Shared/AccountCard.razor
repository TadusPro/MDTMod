@using MDTadusMod.Data
@using MDTadusMod.Services
@using RotMGAssetExtractor.Model
@using System.Diagnostics
@inject AssetService AssetService
@inject SettingsService SettingsManager
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

@if (Account != null && ViewOptions != null)
{
    int batchSize = 8;
    <div @ref="_muleContainer" class="mule">
        <header>
                <span class="scont">
                    <span>@(AccountData?.Star)</span>
                    <span class="star">★</span>
                </span>
            @if (ViewOptions.IGN)
            {
                <p class="mule-name" style="grid-column: 2;">@(AccountData?.Name ?? Account.Email)</p>
            }
            <button @onclick="OnRefreshClicked" disabled="@IsRefreshing" style="grid-column: 3;">
                ↻
            </button>
        </header>

        @if (ViewOptions.Characters)
        {
            <div class="chars" style="--char-row-length: @_effectiveCharRowLength;">
                @if (AccountData?.Characters?.Any() == true)
                {
                    IOrderedEnumerable<Character> orderedCharacters;
                    switch (ViewOptions.CharOrder)
                    {
                        case CharOrder.PlayTime:
                            // Assuming higher fame indicates more playtime.
                            orderedCharacters = AccountData.Characters.OrderByDescending(c => c.CurrentFame); // whateverstat is playtime);
                            break;
                        case CharOrder.Class:
                            orderedCharacters = AccountData.Characters.OrderBy(c => c.ObjectType);
                            break;
                        case CharOrder.BaseFame:
                            orderedCharacters = AccountData.Characters.OrderByDescending(c => c.CurrentFame);
                            break;
                        case CharOrder.TotalFame:
                            orderedCharacters = AccountData.Characters.OrderByDescending(c => PCStatsParser.CalculateTotalFame(c.CurrentFame, CharacterFameBonuses.GetValueOrDefault(c.Id, new List<FameBonus>())));
                            break;
                        case CharOrder.MaxedStats:
                            orderedCharacters = AccountData.Characters.OrderByDescending(c => CharacterMaxedStatsCount.GetValueOrDefault(c.Id, 0));
                            break;
                        default:
                            orderedCharacters = AccountData.Characters.OrderBy(c => c.Id);
                            break;

                    }
                    foreach (var character in orderedCharacters)
                    {
                        <CharacterCard Character="character"
                                       ViewOptions="ViewOptions"
                                       MaxStatsPerClass="MaxStatsPerClass"
                                       ClassIdToNameMap="ClassIdToNameMap"
                                       PCStatIdToNameMap="PCStatIdToNameMap"
                                       CharacterFameBonuses="CharacterFameBonuses" />
                    }
                }
                else
                {
                    <p>No characters to display.</p>
                }
            </div>
        }

        @if (ViewOptions.Vaults && AccountData?.Vault?.Chests?.Any() == true)
        {
            var vaultItems = AccountData.Vault.Chests.SelectMany(c => c.Items).ToList();
            <div class="vaults" style="--char-row-length: @_effectiveCharRowLength;">
                @for (int i = 0; i < vaultItems.Count; i += batchSize)
                {
                    <div class="item-container">
                        @foreach (var item in vaultItems.Skip(i).Take(batchSize))
                        {
                            var typeStr = item.Contains('#') ? item.Split('#')[0] : item;
                            <SpriteCard Type="@typeStr" />
                        }
                    </div>
                }
            </div>
        }

        @if (ViewOptions.Potions && AccountData?.Potions?.Any() == true)
        {
            var potions = AccountData.Potions;
            <div class="potions" style="--char-row-length: @_effectiveCharRowLength;">
                @for (int i = 0; i < potions.Count; i += batchSize)
                {
                    <div class="item-container">
                        @foreach (var item in potions.Skip(i).Take(batchSize))
                        {
                            var typeStr = item.Contains('#') ? item.Split('#')[0] : item;
                            <SpriteCard Type="@typeStr" />
                        }
                    </div>
                }
            </div>
        }

        @if (ViewOptions.Materials && AccountData?.MaterialStorage?.Chests?.Any() == true)
        {
            var materialItems = AccountData.MaterialStorage.Chests.SelectMany(c => c.Items).ToList();
            <div class="materials" style="--char-row-length: @_effectiveCharRowLength;">
                @for (int i = 0; i < materialItems.Count; i += batchSize)
                {
                    <div class="item-container">
                        @foreach (var item in materialItems.Skip(i).Take(batchSize))
                        {
                            var typeStr = item.Contains('#') ? item.Split('#')[0] : item;
                            <SpriteCard Type="@typeStr" />
                        }
                    </div>
                }
            </div>
        }

        @if (ViewOptions.Spoils && AccountData?.TemporaryGifts?.Any() == true)
        {
            var spoils = AccountData.TemporaryGifts;
            <div class="spoils" style="--char-row-length: @_effectiveCharRowLength;">
                @for (int i = 0; i < spoils.Count; i += batchSize)
                {
                    <div class="item-container">
                        @foreach (var item in spoils.Skip(i).Take(batchSize))
                        {
                            var typeStr = item.Contains('#') ? item.Split('#')[0] : item;
                            <SpriteCard Type="@typeStr" />
                        }
                    </div>
                }
            </div>
        }

        @if (ViewOptions.Gifts && AccountData?.Gifts?.Any() == true)
        {
            var items = AccountData.Gifts;
            <div class="gifts" style="--char-row-length: @_effectiveCharRowLength;">
                @for (int i = 0; i < items.Count; i += batchSize)
                {
                    <div class="item-container">
                        @foreach (var item in items.Skip(i).Take(batchSize))
                        {
                            var typeStr = item.Contains('#') ? item.Split('#')[0] : item;
                            <SpriteCard Type="@typeStr" />
                        }
                    </div>
                }
            </div>
        }
    </div>
}


@code {
    [Parameter]
    public MDTadusMod.Data.Account Account { get; set; }

    [Parameter]
    public MDTadusMod.Data.AccountData AccountData { get; set; }

    [Parameter]
    public AccountViewOptions ViewOptions { get; set; }

    [Parameter]
    public string Status { get; set; }

    [Parameter]
    public bool IsRefreshing { get; set; }

    [Parameter]
    public EventCallback OnRefreshClicked { get; set; }

    [Parameter]
    public EventCallback OnDetailsClicked { get; set; }
    public bool displayCategoryTitle = true;

    private Dictionary<int, Dictionary<string, int>> MaxStatsPerClass;
    private Dictionary<int, string> ClassIdToNameMap = new();
    private Dictionary<int, string> PCStatIdToNameMap = new();
    private Dictionary<int, List<FameBonus>> CharacterFameBonuses = new();
    private Dictionary<int, int> CharacterMaxedStatsCount = new();

    private ElementReference _muleContainer;
    private int _effectiveCharRowLength;
    private DotNetObjectReference<AccountCard> _dotNetObjectReference;


    protected override async Task OnInitializedAsync()
    {
        _dotNetObjectReference = DotNetObjectReference.Create(this);
        // Fallback if the parameter is not provided
        if (ViewOptions == null)
        {
            ViewOptions = SettingsManager.GlobalOptions;
        }
        // Set initial value from settings to prevent starting at 1
        _effectiveCharRowLength = ViewOptions.CharRowLength;
        SettingsManager.OnChange += HandleSettingsChanged;
        MaxStatsPerClass = await AssetService.GetMaxStatsPerClass();
    }

    private async void HandleSettingsChanged()
    {
        // When settings change, we need to re-evaluate the row length.
        // We can do this by getting the current body width and calling our existing logic.
        try
        {
            var bodyWidth = await JSRuntime.InvokeAsync<double>("getBodyWidth");
            OnElementResized(bodyWidth);
        }
        catch (Exception ex)
        {
            // Handle potential JS interop errors
            Debug.WriteLine($"[AccountCard] Failed to recalculate row length on settings change: {ex.Message}");
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        // This runs every time parameters are set. Ideal for parameter-dependent logic.
        if (AccountData?.Characters?.Any() == true)
        {
            CharacterFameBonuses.Clear();
            CharacterMaxedStatsCount.Clear();
            // Fetch class names for any new class IDs
            var classTasks = AccountData.Characters
                .Select(c => c.ObjectType)
                .Distinct()
                .Where(id => !ClassIdToNameMap.ContainsKey(id))
                .Select(async id => new { Id = id, Name = await AssetService.GetClassNameById(id) });

            foreach (var task in await Task.WhenAll(classTasks))
            {
                ClassIdToNameMap[task.Id] = task.Name;
            }

            // Fetch stat names for any new stat IDs
            var statTasks = AccountData.Characters
                .SelectMany(c => c.ParsedPCStats.Keys)
                .Distinct()
                .Where(id => !PCStatIdToNameMap.ContainsKey(id))
                .Select(async id => new { Id = id, Name = await AssetService.GetPCStatName(id) });

            foreach (var task in await Task.WhenAll(statTasks))
            {
                PCStatIdToNameMap[task.Id] = task.Name;
            }

            var bonusTasks = AccountData.Characters.Select(async c => new
            {
                CharacterId = c.Id,
                Bonuses = await PCStatsParser.EvaluateBonuses(c)
            });

            foreach (var result in await Task.WhenAll(bonusTasks))
            {
                CharacterFameBonuses[result.CharacterId] = result.Bonuses;
            }

            var maxedStatsTasks = AccountData.Characters.Select(async c => new
            {
                CharacterId = c.Id,
                Count = await AssetService.GetMaxedStatsCount(c)
            });

            foreach (var result in await Task.WhenAll(maxedStatsTasks))
            {
                CharacterMaxedStatsCount[result.CharacterId] = result.Count;
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("observeResize", _dotNetObjectReference, _muleContainer);
        }
        await base.OnAfterRenderAsync(firstRender);
    }

    [JSInvokable]
    public void OnElementResized(double bodyWidth)
    {
        if (ViewOptions == null) return;

        var somethingChanged = false;

        // --- Character Row Calculation ---
        if (ViewOptions.Characters && bodyWidth > 0)
        {
            int newEffectiveLength;

            if (AccountData?.Characters?.Any() == true)
            {
                // Calculate length based on screen size and character count
                const double cardWidth = 180;
                const double gap = 5;
                const double safetyMargin = 20;

                var effectiveWidth = bodyWidth - safetyMargin;
                var maxFit = Math.Floor((effectiveWidth + gap) / (cardWidth + gap));
                var newLength = Math.Min(ViewOptions.CharRowLength, (int)maxFit);
                newLength = Math.Min(newLength, AccountData.Characters.Count);
                newEffectiveLength = Math.Max(1, newLength);
            }
            else
            {
                // If there are no characters, default the length to 1.
                newEffectiveLength = 1;
            }

            if (newEffectiveLength != _effectiveCharRowLength)
            {
                _effectiveCharRowLength = newEffectiveLength;
                somethingChanged = true;
            }
        }

        if (somethingChanged)
        {
            StateHasChanged();
        }
    }

    public async ValueTask DisposeAsync()
    {
        SettingsManager.OnChange -= HandleSettingsChanged;
        if (_muleContainer.Id != null)
        {
            await JSRuntime.InvokeVoidAsync("unobserveResize", _muleContainer);
        }
        _dotNetObjectReference?.Dispose();
    }
}