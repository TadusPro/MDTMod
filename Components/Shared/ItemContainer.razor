@using MDTadusMod.Data
@using MDTadusMod.Services
@using System.Diagnostics
@inject SettingsService SettingsManager

@if (Items?.Any() == true)
{
    @if (DisplayType == ContainerDisplayType.total)
    {
        <div class="@CssClass summarized-container" @attributes="FilteredAttributes">
            @foreach (var itemGroup in GroupedItems)
            {
                <div class="summarized-item">
                    <SpriteCard Type="@itemGroup.Key.ItemId" Rarity="@itemGroup.Key.Rarity" Count="@itemGroup.Value" />
                </div>
            }
            @if (EmptySlotCount > 0)
            {
                <div class="summarized-item empty-slot">
                    <SpriteCard Type="-1" Rarity="0" Count="@EmptySlotCount" />
                </div>
            }
        </div>
    }
    else
    {
        <div class="@CssClass" @attributes="FilteredAttributes">
            @for (int i = 0; i < PaddedItems.Count; i += BatchSize)
            {
                <div class="item-container">
                    @foreach (var item in PaddedItems.Skip(i).Take(BatchSize))
                    {
                        <SpriteCard Type="@item.Id" Rarity="@GetEnchantCount(item.RawEnchantData)" />
                    }
                </div>
            }
        </div>
    }
}

@code {
    [Parameter, EditorRequired]
    public List<Item> Items { get; set; }

    [Parameter]
    public int BatchSize { get; set; } = 8;

    [Parameter]
    public bool NoPadding { get; set; } = false;

    [Parameter]
    public ContainerDisplayType DisplayType { get; set; } = ContainerDisplayType.chest;

    [Parameter(CaptureUnmatchedValues = true)]
    public IReadOnlyDictionary<string, object> AdditionalAttributes { get; set; }

    private List<Item> PaddedItems { get; set; } = new();
    private Dictionary<(int ItemId, int Rarity), int> GroupedItems { get; set; } = new();
    private int EmptySlotCount { get; set; } = 0;
    private string CssClass { get; set; }
    private IReadOnlyDictionary<string, object> FilteredAttributes { get; set; }

    protected override void OnInitialized()
    {
        SettingsManager.OnChange += StateHasChanged;
    }

    protected override void OnParametersSet()
    {
        // Combine the base class with any user-provided class.
        var cssClass = "item-section";
        if (AdditionalAttributes?.TryGetValue("class", out var userClass) == true)
        {
            cssClass += $" {userClass}";
        }
        if (NoPadding)
        {
            cssClass += " no-padding";
        }
        CssClass = cssClass;

        // Filter out the 'class' attribute so it's not applied twice.
        FilteredAttributes = AdditionalAttributes?.Where(a => a.Key != "class").ToDictionary(a => a.Key, a => a.Value)
                             ?? new Dictionary<string, object>();

        if (Items != null)
        {
            if (DisplayType == ContainerDisplayType.total)
            {
                // Count empty slots
                EmptySlotCount = Items.Count(item => item.Id == -1);
                
                // Group items based on the GroupRarities setting
                if (SettingsManager.GlobalSettings.GroupRarities)
                {
                    // Group by ID and rarity (keep rarities separate)
                    GroupedItems = Items
                        .Where(item => item.Id != -1)
                        .GroupBy(item => (ItemId: item.Id, Rarity: GetEnchantCount(item.RawEnchantData)))
                        .ToDictionary(g => g.Key, g => g.Count());
                }
                else
                {
                    // Group by ID only, ignoring rarity
                    GroupedItems = Items
                        .Where(item => item.Id != -1)
                        .GroupBy(item => item.Id)
                        .ToDictionary(
                            g => (ItemId: g.Key, Rarity: 0), // Use 0 as a placeholder rarity
                            g => g.Count()
                        );
                }
            }
            else
            {
                // Original chest display logic
                PaddedItems = new List<Item>(Items);
                if (!NoPadding)
                {
                    var remainder = PaddedItems.Count % BatchSize;
                    if (remainder > 0)
                    {
                        for (int i = 0; i < BatchSize - remainder; i++)
                        {
                            PaddedItems.Add(new Item { Id = -1 });
                        }
                    }
                }
            }
        }
        else
        {
            PaddedItems.Clear();
            GroupedItems.Clear();
            EmptySlotCount = 0;
        }
        base.OnParametersSet();
    }

    private int GetEnchantCount(string enchantData)
    {
        var enchants = new List<int>();
        if (string.IsNullOrEmpty(enchantData))
        {
            return 0;
        }

        byte[] data = Convert.FromBase64String(enchantData.Replace('-', '+').Replace('_', '/'));
        if (data.Length == 0)
        {
            return 0;
        }

        int index = 0;
        byte version = data[index];
        index++;

        const byte GradeId = 1;
        const byte EnchantmentSlotId = 2;
        const byte EnchantmentListId = 3;
        const byte RerollCountId = 4;
        const byte PowerupInfoId = 5;

        while (index < data.Length)
        {
            byte type = data[index];
            index++;

            switch (type)
            {
                case GradeId:
                    {
                        byte grade = data[index];
                        index++;
                        byte count = data[index];
                        index++;

                        //skip over key mods
                        index += count * sizeof(short);
                        break;
                    }
                case EnchantmentSlotId:
                    {
                        byte count = data[index];
                        index++;

                        for (int i = 0; i < count; i++)
                        {
                            short enchantmentId = BitConverter.ToInt16(data, index);
                            index += sizeof(short);
                            enchants.Add(enchantmentId);
                        }

                        break;
                    }
                case EnchantmentListId:
                    {
                        ushort count = BitConverter.ToUInt16(data, index);
                        index += sizeof(ushort);

                        index += count * sizeof(short);

                        break;
                    }
                case RerollCountId:
                    {
                        byte rerollCount = data[index];
                        index++;
                        break;
                    }
                case PowerupInfoId:
                    {
                        byte count = data[index];
                        index++;
                        for (int i = 0; i < count; i++)
                        {
                            byte id = data[index];
                            index++;
                            ushort value = BitConverter.ToUInt16(data, index);
                            index += sizeof(ushort);
                        }

                        break;
                    }
            }
        }

        return enchants.Count(id => id != -3);
    }

    public void Dispose()
    {
        SettingsManager.OnChange -= StateHasChanged;
    }
}