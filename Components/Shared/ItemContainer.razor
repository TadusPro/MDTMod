@using MDTadusMod.Data
@using MDTadusMod.Services
@inject SettingsService SettingsManager

@if (Items?.Any() == true)
{
    @if (DisplayType == ContainerDisplayType.Summarized)
    {
        <div class="@CssClass summarized-container" @attributes="FilteredAttributes">
            @foreach (var itemGroup in GroupedItems)
            {
                <div class="summarized-item">
                    <SpriteCard Type="@itemGroup.Key.ItemId" Rarity="@itemGroup.Key.Rarity" />
                    <span class="item-count">@itemGroup.Value</span>
                </div>
            }
            @if (EmptySlotCount > 0)
            {
                <div class="summarized-item empty-slot">
                    <SpriteCard Type="-1" Rarity="0" />
                    <span class="item-count">@EmptySlotCount</span>
                </div>
            }
        </div>
    }
    else
    {
        <div class="@CssClass" @attributes="FilteredAttributes">
            @for (int i = 0; i < PaddedItems.Count; i += BatchSize)
            {
                <div class="item-container">
                    @foreach (var item in PaddedItems.Skip(i).Take(BatchSize))
                    {
                        <SpriteCard Type="@item.Id" Rarity="@GetRarityFromEnchantments(item.RawEnchantData)" />
                    }
                </div>
            }
        </div>
    }
}

@code {
    [Parameter, EditorRequired]
    public List<Item> Items { get; set; }

    [Parameter]
    public int BatchSize { get; set; } = 8;

    [Parameter]
    public bool NoPadding { get; set; } = false;

    [Parameter]
    public ContainerDisplayType DisplayType { get; set; } = ContainerDisplayType.Chest;

    [Parameter(CaptureUnmatchedValues = true)]
    public IReadOnlyDictionary<string, object> AdditionalAttributes { get; set; }

    private List<Item> PaddedItems { get; set; } = new();
    private Dictionary<(int ItemId, int Rarity), int> GroupedItems { get; set; } = new();
    private int EmptySlotCount { get; set; } = 0;
    private string CssClass { get; set; }
    private IReadOnlyDictionary<string, object> FilteredAttributes { get; set; }

    protected override void OnInitialized()
    {
        SettingsManager.OnChange += StateHasChanged;
    }

    protected override void OnParametersSet()
    {
        // Combine the base class with any user-provided class.
        var cssClass = "item-section";
        if (AdditionalAttributes?.TryGetValue("class", out var userClass) == true)
        {
            cssClass += $" {userClass}";
        }
        if (NoPadding)
        {
            cssClass += " no-padding";
        }
        CssClass = cssClass;

        // Filter out the 'class' attribute so it's not applied twice.
        FilteredAttributes = AdditionalAttributes?.Where(a => a.Key != "class").ToDictionary(a => a.Key, a => a.Value)
                             ?? new Dictionary<string, object>();

        if (Items != null)
        {
            if (DisplayType == ContainerDisplayType.Summarized)
            {
                // Count empty slots
                EmptySlotCount = Items.Count(item => item.Id == -1);
                
                // Group items based on the GroupRarities setting
                if (SettingsManager.GlobalSettings.GroupRarities)
                {
                    // Group by ID and rarity (keep rarities separate)
                    GroupedItems = Items
                        .Where(item => item.Id != -1)
                        .GroupBy(item => (ItemId: item.Id, Rarity: GetRarityFromEnchantments(item.RawEnchantData)))
                        .ToDictionary(g => g.Key, g => g.Count());
                }
                else
                {
                    // Group by ID only, ignoring rarity
                    GroupedItems = Items
                        .Where(item => item.Id != -1)
                        .GroupBy(item => item.Id)
                        .ToDictionary(
                            g => (ItemId: g.Key, Rarity: 0), // Use 0 as a placeholder rarity
                            g => g.Count()
                        );
                }
            }
            else
            {
                // Original chest display logic
                PaddedItems = new List<Item>(Items);
                if (!NoPadding)
                {
                    var remainder = PaddedItems.Count % BatchSize;
                    if (remainder > 0)
                    {
                        for (int i = 0; i < BatchSize - remainder; i++)
                        {
                            PaddedItems.Add(new Item { Id = -1 });
                        }
                    }
                }
            }
        }
        else
        {
            PaddedItems.Clear();
            GroupedItems.Clear();
            EmptySlotCount = 0;
        }
        base.OnParametersSet();
    }

    private int GetRarityFromEnchantments(string enchantData)
    {
        if (string.IsNullOrEmpty(enchantData)) return 0;

        string standardBase64 = enchantData.Replace('_', '/').Replace('-', '+');
        int padding = standardBase64.Length % 4;
        if (padding != 0)
        {
            standardBase64 += new string('=', 4 - padding);
        }
        if (standardBase64.Length < 4) return 0;
        try
        {
            byte[] decodedBytes = Convert.FromBase64String(standardBase64);
            using var memoryStream = new MemoryStream(decodedBytes);
            using var reader = new BinaryReader(memoryStream);

            if (reader.BaseStream.Length < 3) return 0;
            reader.BaseStream.Position = 3;

            int enchantmentCount = 0;
            while (reader.BaseStream.Position + 2 <= reader.BaseStream.Length)
            {
                ushort enchantId = reader.ReadUInt16();
                if (enchantId == 0xFFFD) break;
                if (enchantId != 0xFFFE)
                {
                    enchantmentCount++;
                }
            }
            return enchantmentCount;
        }
        catch
        {
            return 0;
        }
    }

    public void Dispose()
    {
        SettingsManager.OnChange -= StateHasChanged;
    }
}