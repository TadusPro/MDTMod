@namespace MDTadusMod.Components.Shared
@using MDTadusMod.Services
@using System.Diagnostics
@inject AssetService AssetService

<div class="sprite-card @(BackgroundOff ? "no-background" : "")"
     type="@Id"
     style="transform: rotate(@RotationDeg);">
    @if (isLoading)
    {
        <div class="loading-spinner"></div>
    }
    else if (!string.IsNullOrEmpty(itemImage))
    {
        <img src="@itemImage" alt="Item ID: @Id" class="item-sprite" />
        @if (!string.IsNullOrEmpty(EnchantmentOverlayImage))
        {
            <img src="@EnchantmentOverlayImage" class="enchantment-overlay" alt="Enchantment Overlay" />
        }
    }
    else if (unknownid && Id != -1)
    {
        <span class="unknown">
            @Id
        </span>
    }
    else
    {
        <span></span>
    }
</div>

@code {
    [Parameter]
    public object Type { get; set; }

    [Parameter]
    public bool BackgroundOff { get; set; }

    private int Id = -1;
    private string EnchantData;
    private List<KeyValuePair<int, int>> ParsedEnchantments = new();
    private string EnchantmentOverlayImage;
    private bool unknownid = true;
    private string itemImage;
    private bool isLoading = false;

    private int RotationDeg;

    protected override async Task OnParametersSetAsync()
    {
        // Generate a random rotation between -15 and 15 degrees
        var rand = new Random(Guid.NewGuid().GetHashCode());
        RotationDeg = rand.Next(-15, 16);

        // Reset state
        itemImage = null;
        unknownid = true;
        Id = -1;
        EnchantData = null;
        EnchantmentOverlayImage = null;
        ParsedEnchantments.Clear();
        isLoading = true;

        if (Type is int id)
        {
            Id = id;
        }
        else if (Type is string typeString)
        {
            var parts = typeString.Split(':', 2);
            if (int.TryParse(parts[0], out var parsedId))
            {
                Id = parsedId;
                if (parts.Length > 1)
                {
                    EnchantData = parts[1];
                    ParsedEnchantments = ParseEnchantments(EnchantData);
                    SetEnchantmentOverlay();
                }
            }
        }

        if (Id != -1)
        {
            itemImage = await AssetService.GetItemImageAsBase64Async(Id);
            if (!string.IsNullOrEmpty(itemImage))
            {
                unknownid = false;
            }
        }

        isLoading = false;
    }

    private void SetEnchantmentOverlay()
    {
        // Count the number of actual enchantments, excluding locked slots.
        var enchantmentCount = ParsedEnchantments.Count(kvp => kvp.Key != -1);

        if (enchantmentCount == 0)
        {
            EnchantmentOverlayImage = null;
            return;
        }

        // Assign an overlay based on the number of enchantments.
        EnchantmentOverlayImage = enchantmentCount switch
        {
            1 => "/images/uncommon.png",
            2 => "/images/rare.png",
            3 => "/images/legendary.png",
            4 => "/images/divine.png",
            // Add more cases if you have more rarity tiers
            _ => null // No overlay for 0 or unhandled counts
        };
    }

    private List<KeyValuePair<int, int>> ParseEnchantments(string enchantData)
    {
        var enchantments = new List<KeyValuePair<int, int>>();
        if (string.IsNullOrEmpty(enchantData)) return enchantments;

        string standardBase64 = enchantData.Replace('_', '/').Replace('-', '+');
        int padding = standardBase64.Length % 4;
        if (padding != 0)
        {
            standardBase64 += new string('=', 4 - padding);
        }

        try
        {
            byte[] decodedBytes = Convert.FromBase64String(standardBase64);
            using var memoryStream = new MemoryStream(decodedBytes);
            using var reader = new BinaryReader(memoryStream);

            // Skip 3-byte header
            if (reader.BaseStream.Length < 3) return enchantments;
            reader.BaseStream.Position = 3;

            while (reader.BaseStream.Position + 2 <= reader.BaseStream.Length)
            {
                ushort enchantId = reader.ReadUInt16();

                if (enchantId == 0xFFFD) // End of enchantments marker
                {
                    break;
                }

                if (enchantId == 0xFFFE) // Locked Enchant Slot
                {
                    // Storing with a special key to identify it as a locked slot.
                    enchantments.Add(new KeyValuePair<int, int>(-1, 0));
                }
                else
                {
                    // Add a record for the enchantment. The value is not used for rarity.
                    enchantments.Add(new KeyValuePair<int, int>(0, (int)enchantId));
                }
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Failed to parse enchantment data for ID {Id}. Error: {ex.Message}");
        }
        return enchantments;
    }
}